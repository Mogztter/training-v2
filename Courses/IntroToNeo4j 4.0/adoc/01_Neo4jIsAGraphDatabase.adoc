
= Neo4j is a Graph Database
:presenter: Neo Technology
:twitter: neo4j
:email: info@neotechnology.com
:neo4j-version: 4.0
:currentyear: 2020
:doctype: book
:nextsecttitle: The Neo4j Graph Platform
:nextsect: 2
:currsect: 1
:prevsecttitle: About this Course
:prevsect: 0
:toc: left
:toclevels: 3
:experimental:
:imagedir: https://s3-us-west-1.amazonaws.com/data.neo4j.com/intro-neo4j-4.0/img
:manual: http://neo4j.com/docs/developer-manual/current
:manual-cypher: {manual}/cypher

ifdef::backend-html5[]

include::scripts.txt[]

endif::backend-html5[]

== About this module

Neo4j enables developers to create applications that are best architected as graph-powered systems that are built upon the rich connectedness of data.

At the end of this module, you should be able to:
[square]
* Describe what a graph is.
* Describe what a graph database is.
* Describe some common use cases for using a graph database.
* Describe the Neo4j property graph model.
* Whiteboard a graph data model.

=== What is a graph?

A graph is a collection of objects, each of which has links with the other objects.

Graphs are a useful way to model data for the purposes of mathematical analysis, and they have been around for quite a long time.
The first use of graphs was by Leonhard Euler in 1735; he used graph theory to prove that the famous *Seven Bridges of Konigsberg* problem had no solution.

Konigsberg, Prussia (now Kaliningrad, Russia) is a city spanning the Pregel River.
It includes two large islands, which are connected to one another and to the river banks by seven bridges.
A map of this arrangement is pictured here:

image::{imagedir}/SevenBridges.png[SevenBridges,width=700,align=center]

The Seven Bridges problem is this: Is there any possible route through the city that crosses every bridge exactly once?
Some pen-and-paper experimentation will quickly suggest that there is no such route.
However, PROVING that there is no solution is much more difficult; Euler invented Graph Theory as a tool to aid this proof.
The graph representation of the problem is on the right:  four land masses, each represented by a node, and seven bridges, each represented by a relationship.

Euler observed the following:

[square]
* The route taken within each landmass is irrelevant.  Only the sequence of bridges crossed matters.
* Whenever you enter a land mass via a bridge, you must leave it by a different bridge.
** ...except at the start (where you leave but do not enter) and at the end (where you enter but do not leave).
*Thus, for the problem to be solvable, every land mass (except the start and end) must be touched by an even number of bridges.

Based on the above observations, the problem has no solution, because all four of the land masses are touched by an odd number of bridges.

=== Anything can be a graph

But if graphs are an abstract mathematical tool, why do we care about them?

We care because any dataset can be represented as a graph.
Any structure or concept, no matter how simple or complex, can be broken down into a set constituent parts that have some relationship to one another.

For example, the internet can be modeled as a network of computers.

image::{imagedir}/TheInternetAsAGraph.png[TheInternetAsAGraph,width=400,align=center]

At the other extreme of complexity, a single molecule can be represented as a graph of its constituent atoms--or an atom represented as a graph of subatomic particles.

image::{imagedir}/AWaterMoleculeAsAGraph.png[AWaterMoleculeAsAGraph,width=400,align=center]

And, as Euler showed, there are some clear benefits to representing data in this way.
We will discuss many of these as we go.
But mainly, graphs are uniquely useful when answering a question that  involves following a path along a chain of related items.

You will frequently hear Neo4j people refer to such questions as graph problems--and they are surprisingly common in the real world.

=== Graph concepts

We will begin by defining the components that make up a graph in Neo4j.
There are two of them: Nodes and Relationships.
Note that these are the Neo4j terms for these objects; the original mathematical terms are Vertex and Edge.
We’ve chosen our nomenclature because it more intuitively describes what the objects represent.

image::{imagedir}/GraphComponents.png[GraphComponents,width=400,align=center]

Here we see two nodes.
These two nodes are related to each other.

==== Nodes

First, let’s define a node.
Nodes are the main objects of a graph.
We say this not because nodes contain more data than relationships--although they usually do--but because it is perfectly acceptable to have nodes without any relationships.
Conversely,  is is not possible to have a relationship without any nodes.

image::{imagedir}/GraphConcepts-Nodes.png[GraphConcepts-Nodes,width=400,align=center]

Here we see that each node has a different color, perhaps to differentiate its type from another node.
For example, the blue node represents a person and that person node has a name of Jane.
The green node represents a vehicle and that vehicle node has a type of car.

Mathematically, a node is defined as “a point where two or more edges (relationships) meet.”
This is not at all intuitive!
However, it provides important insight into how graphs are used.
Since the entire point of modeling data as a graph is to traverse a chain of linked nodes, one useful way of thinking about nodes is that they are waypoints along the traversal route.
They contain information you need to decide which links are good ones to follow, and which should be ignored.
Relationships are those links.

==== Relationships

Next, let’s define a relationship.
Relationships are the links between nodes.  I
n their simplest form, relationships need not contain any information other than which two nodes they link.
But they can (and in Neo4j always do) contain much more.

image::{imagedir}/GraphConcepts-Relationships.png[GraphConcepts-Relationships,width=400,align=center]

For example, relationships can include a direction.
“Jane owns a car” is a very different relationship than “ A car owns Jane,” and the direction of the relationship between Jane and her car captures this.
Relationship directions are required in Neo4j.

In addition, relationships can contain any amount of additional metadata, such as weight or relationship type.
For example, the relationship between Jane and her car is of the type OWNS.
Like direction, Type is a required element of Neo4j relationships, although all other metadata is optional.

In Neo4j, the purpose of the data attached to a relationship is to reduce the need to “gather and inspect,” where you follow all relationships from a given node, then scan the target node data to determine which hops were “good” ones and then discard the rest.
This does not scale well.
Instead, we can use the metadata attached to a relationship to preemptively filter which links to follow during traversal.

==== Traversing a graph

As mentioned before, the main point of graphs is to follow a chain of nodes and relationships; the process of finding such routes is the definition of traversal.
There are many ways a graph can be traversed and there are graph algorithms that perform traversals of all types from random, to shortest path, to longest path.

In Neo4j traversal is optimized since that is how one performs queries in the graph.
During traversal of a Neo4j graph, nodes may be visited more than once, but a relationship is only traversed once.
This is called a path in Neo4j.

image::{imagedir}/GraphConcepts-Traversal.png[GraphConcepts-Traversal,width=400,align=center]

In this example, although the "2" node is visited multiple times, no relationship between the nodes is traversed more than once.
In Neo4j, what makes this possible is:

[square]
* Relationships have direction.
* Relationships have types.

=== What Is a graph database?

A graph database is an online database management system with Create, Read, Update and Delete (CRUD) operations working on a graph data model. 
Graph databases are often used as part of the Enterprise online transaction processing (OLTP) systems.
Accordingly, they are normally optimized for transactional performance, and engineered with transactional integrity and operational availability in mind.

image::{imagedir}/GraphDatabaseInEnterprise.png[GraphDatabaseInEnterprise,width=400,align=center]

Unlike other databases, relationships take first priority in graph databases.  
This means your application doesn't have to infer data connections using foreign keys or out-of-band processing, such as MapReduce.
By assembling the simple abstractions of nodes and relationships into connected structures, graph databases enable us to build sophisticated models that map closely to our problem domain.


=== The case for graph databases

The biggest value that graphs bring to the development stack is their ability to store relationships and connections as first-class entities.

For instance, the early adopters of graph technology reimagined their businesses around the value of data relationships. 
These companies have now become industry leaders: LinkedIn, Google, Facebook and PayPal.

As pioneers in graph technology, each of these enterprises had to build their own graph database from scratch. 
Fortunately for today's developers, that's no longer the case, as graph database technology is now available off the shelf.



=== What is a graph?

A graph is composed of two elements: *nodes* and *relationships*.

Each node represents an entity (a person, place, thing, category or other piece of data). With Neo4j, nodes can have **labels** that are used to define types for nodes. 
For example, a _Location_ node is a node with the label _Location_. 
That same node can also have a label, _Residence_. Another _Location_ node can also have a label, _Business_. 
A label can be used to group nodes of the same type. For example, you may want to retrieve all of the _Business_ nodes.

image::{imagedir}/Nodes.png[Nodes,width=400,align=center]

// force line break

{nbsp} + 

ifdef::backend-pdf[]
[cols=1, frame="none"]
|===
a|
endif::backend-pdf[]
Each relationship represents how two nodes are connected. 
For example, the two nodes _Person_ and _Location_, might have the relationship _LIVES_AT_ pointing from a _Person_ node to _Location_ node.
A relationship represents the verb or action between two entities. The _MARRIED_ relationship is defined from one _Person_ node to another _Person_ node. Although the relationship is defined as directional, it can be queried in a non-directional manner. That is, you can query if two _Person_ nodes have a _MARRIED_ relationship, regardless of the direction of the relationship. For some data models, the direction of the relationship is significant. For example, in Facebook, using the _KNOWS_ relationship is used to indicate which _Person_ invited the other _Person_ to be a friend.

image::{imagedir}/Relationships.png[Relationships,width=400,align=center]
// force line break

{nbsp} +  
This general-purpose structure allows you to model all kinds of scenarios: from a system of roads, to a network of devices, to a population's medical history, or anything else defined by relationships. 
ifdef::backend-pdf[]
|===
endif::backend-pdf[]


ifdef::backend-pdf[]
[cols=1, frame="none"]
|===
a|
endif::backend-pdf[]
The Neo4j database is a property graph. 
You can add **properties** to nodes and relationships to further enrich the graph model. 

image::{imagedir}/Properties.png[Properties,width=500,align=center]
// force line break

{nbsp} +  
This enables you to closely align data and connections in the graph to your real-world application. 
For example, a _Person_ node might have a property, _name_ and a _Location_ node might have a property, _address_. In addition, a relationship, _MARRIED_ , might have a property, _since_.
ifdef::backend-pdf[]
|===
endif::backend-pdf[]


ifdef::backend-pdf[]

In this video, you will learn how to model property graphs containing nodes and relationships and how Cypher is used to access a graph database.

https://youtu.be/NH6WoJHN4UA

endif::backend-pdf[]

ifdef::backend-html5[]
In this video, you will learn how to model property graphs containing nodes and relationships and how Cypher is used to access a graph database.

++++
<iframe width="560" height="315" src="https://www.youtube.com/embed?listType=playlist&#038;list=PL9Hl4pk2FsvWM9GWaguRhlCQ-pa-ERd4U&#038;index=2" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
++++
endif::backend-html5[]

=== Modeling relational to graph

Many applications' data is modeled as relational data. There are some similarities between a relational model and a graph model:

[cols="<.^,<.^", options="header",stripes="none"]
|====
| *Relational*
| *Graph*
|
{set:cellbgcolor:white}
Rows
| Nodes
| Joins
| Relationships
| Table names
| Labels
| Columns
| Properties
|====
{set:cellbgcolor!}

ifdef::backend-pdf[]
// force page break
<<<
endif::backend-pdf[]

But, there are some ways in which the relational model differs from the graph model:

[cols="<.^,<.^", options="header",stripes="none"]
|====
| *Relational*
| *Graph*
| 
{set:cellbgcolor:white}
Each column must have a field value.
| Nodes with the same label aren't required to have the same set of properties.
| Joins are calculated at query time.
| Relationships are stored on disk when they are created.
| A row can belong to one table.
| A node can have many labels.
|====
{set:cellbgcolor!}

==== Run-time behavior: RDBMS vs graph

ifdef::backend-pdf[]
[cols=1, frame="none"]
|===
a|
endif::backend-pdf[]
How data is retrieved is very different between an RDBMS and a graph database:

[.thumb]
image::{imagedir}/RDBvsGraphRuntime.png[RDBvsGraphRuntime,600,align=center]
ifdef::backend-pdf[]
|===
endif::backend-pdf[]

==== How we model: RDBMS vs graph

How you model data from relational vs graph differs:

[cols="<.^,<.^", options="header",stripes="none"]
|====
| *Relational*
| *Graph*
| 
{set:cellbgcolor:white}
Try and get the schema defined and then make minimal changes to it after that.
| It's common for the schema to evolve with the application.
| More abstract focus when modeling i.e. focus on classes rather than objects.
| Common to use actual data items when modeling.
|====
{set:cellbgcolor!}

If we were modeling a football transfers graph in relational and graph databases these diagrams show what common approaches might look like.

ifdef::backend-pdf[]
[cols=1, frame="none"]
|===
a|
endif::backend-pdf[]
Here is the relational model:

[.thumb]
image::{imagedir}/RDB.png[RDB,600,400,align=center]
ifdef::backend-pdf[]
|===
endif::backend-pdf[]

ifdef::backend-pdf[]
[cols=1, frame="none"]
|===
a|
endif::backend-pdf[]
and here is the corresponding graph model:


[.thumb]
image::{imagedir}/RDBToGraph.png[RDBToGraph,width=600,align=center]

With the graph model we might sketch out examples with actual values and derive the 'schema' while doing that modeling process.
ifdef::backend-pdf[]
|===
endif::backend-pdf[]

ifdef::backend-pdf[]
[cols=1, frame="none"]
|===
a|
endif::backend-pdf[]
In Neo4j, the data model might evolve to something like this:

[.thumb]
image::{imagedir}/GraphModel.png[GraphModel,width=1000,align=center]
ifdef::backend-pdf[]
|===
endif::backend-pdf[]

=== How does Neo4j support the property graph model?
[square]
* Neo4j is a *Database* - use it to reliably *store information* and *find it later*.
* Neo4j's data model is a *Graph*, in particular a *Property Graph*.
* *Cypher* is Neo4j's graph query language (*SQL for graphs!*).
* Cypher is a declarative query language: it describes *what* you are interested in, not *how* it is acquired.
* Cypher is meant to be very *readable* and *expressive*.

[#module-1.quiz]
== Check your understanding
=== Question 1

What elements make up a graph?

Select the correct answers.
[%interactive]
- [ ] [.false-answer]#tuples#
- [ ] [.required-answer]#nodes#
- [ ] [.false-answer]#documents#
- [ ] [.required-answer]#relationships#

=== Question 2

Suppose that you want to create a graph to model customers, products, what products a customer buys, and what products a customer rated. You have created nodes in the graph to represent the customers and products. In this graph, what relationships would you define?

Select the correct answers.
[%interactive]
- [ ] [.required-answer]#BOUGHT#
- [ ] [.false-answer]#IS_A_CUSTOMER#
- [ ] [.false-answer]#IS_A_PRODUCT#
- [ ] [.required-answer]#RATED#

=== Question 3

What query language is used with a Neo4j Database?

Select the correct answer.
[%interactive]
- [ ] [.false-answer]#SQL#
- [ ] [.false-answer]#CQL#
- [ ] [.required-answer]#Cypher#
- [ ] [.false-answer]#OPath#

== Summary

You should now be able to:
[square]
* Describe what a graph database is.
* Describe some common use cases for using a graph database.
* Describe how real-world scenarios are modeled as a graph.

== Grade Quiz and Continue 

++++
<a class="next-section medium button" href="../part-2/">Continue to Module 2</a>
++++

ifdef::backend-html5[]
include::scripts-end.txt[]

++++
<script>
$( document ).ready(function() {
  Intercom('trackEvent','training-introv2-view-part1');
});
</script>
++++

endif::backend-html5[]
